//
//  Serialization.swift
//  react-native-homeatlas
//
//  Provides serialization helpers to convert HomeKit types to JavaScript-compatible objects
//  using the Codable snapshots generated by @Snapshotable macro.
//

import Foundation

#if canImport(HomeKit)
import HomeKit

/// Serialization helpers for converting HomeKit entities using Codable snapshots.
@MainActor
enum Serialization {

    // MARK: - Encoding (HomeKit → JavaScript)

    /// Serialize a HomeKit home to a dictionary using its Codable snapshot.
    static func serializeHome(_ home: HMHome) -> Any {
        encode(home.snapshot)
    }

    /// Serialize a HomeKit accessory to a dictionary using its Codable snapshot.
    static func serializeAccessory(_ accessory: HMAccessory) -> Any {
        encode(accessory.snapshot)
    }

    /// Serialize a HomeKit room to a dictionary using its Codable snapshot.
    static func serializeRoom(_ room: HMRoom) -> Any {
        encode(room.snapshot)
    }

    /// Serialize a HomeKit service to a dictionary using its Codable snapshot.
    static func serializeService(_ service: HMService) -> Any {
        encode(service.snapshot)
    }

    /// Serialize a HomeKit characteristic to a dictionary using its Codable snapshot.
    static func serializeCharacteristic(_ characteristic: HMCharacteristic) -> Any {
        encode(characteristic.snapshot)
    }

    // MARK: - Encoding Helper

    /// Encode a Codable value to a JSON-compatible object (dictionary/array/primitive).
    private static func encode<T: Encodable>(_ value: T) -> Any {
        let encoder = JSONEncoder()

        guard let data = try? encoder.encode(value),
              let json = try? JSONSerialization.jsonObject(with: data) else {
            return NSNull()
        }

        return json
    }

    // MARK: - Deserialization (JavaScript → HomeKit)

    /// Deserialize a JavaScript value to a HomeKit characteristic value based on metadata.
    static func deserializeCharacteristicValue(_ value: Any, for characteristic: HMCharacteristic) -> Any? {
        // Get the expected format from metadata
        guard let metadata = characteristic.metadata else {
            // No metadata, try to infer from current value
            if let currentValue = characteristic.value {
                return coerceValue(value, toTypeOf: currentValue)
            }
            // Last resort: return as-is
            return value
        }

        // Use metadata format to deserialize
        switch metadata.format {
        case HMCharacteristicMetadataFormatBool:
            if let boolValue = value as? Bool {
                return boolValue
            }
            if let intValue = value as? Int {
                return intValue != 0
            }
            return nil

        case HMCharacteristicMetadataFormatInt,
             HMCharacteristicMetadataFormatUInt8,
             HMCharacteristicMetadataFormatUInt16,
             HMCharacteristicMetadataFormatUInt32,
             HMCharacteristicMetadataFormatUInt64:
            // All integer types handled the same way
            if let intValue = value as? Int {
                return intValue
            }
            if let doubleValue = value as? Double {
                return Int(doubleValue)
            }
            return nil

        case HMCharacteristicMetadataFormatFloat:
            if let doubleValue = value as? Double {
                return Float(doubleValue)
            }
            if let intValue = value as? Int {
                return Float(intValue)
            }
            return nil

        case HMCharacteristicMetadataFormatString:
            if let stringValue = value as? String {
                return stringValue
            }
            return String(describing: value)

        case HMCharacteristicMetadataFormatData:
            if let dataValue = value as? Data {
                return dataValue
            }
            if let arrayValue = value as? [UInt8] {
                return Data(arrayValue)
            }
            return nil

        default:
            return value
        }
    }

    /// Coerce a value to match the type of a reference value.
    private static func coerceValue(_ value: Any, toTypeOf reference: Any) -> Any? {
        switch reference {
        case is Bool:
            if let boolValue = value as? Bool {
                return boolValue
            }
            if let intValue = value as? Int {
                return intValue != 0
            }
            return nil

        case is Int:
            if let intValue = value as? Int {
                return intValue
            }
            if let doubleValue = value as? Double {
                return Int(doubleValue)
            }
            return nil

        case is Float:
            if let doubleValue = value as? Double {
                return Float(doubleValue)
            }
            if let intValue = value as? Int {
                return Float(intValue)
            }
            return nil

        case is Double:
            if let doubleValue = value as? Double {
                return doubleValue
            }
            if let intValue = value as? Int {
                return Double(intValue)
            }
            return nil

        case is String:
            if let stringValue = value as? String {
                return stringValue
            }
            return String(describing: value)

        default:
            return value
        }
    }
}

#endif
