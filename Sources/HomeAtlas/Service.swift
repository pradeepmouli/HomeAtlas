import Foundation

#if canImport(HomeKit)
import HomeKit

/// Marker protocol that all generated service wrappers conform to.
@MainActor
public protocol GeneratedService {
    /// The HomeKit service type identifier represented by the generated wrapper.
    static var serviceType: String { get }

    /// Initializes the wrapper from the underlying HomeKit service.
    init(underlying: HMService)
}

/// A strongly-typed wrapper for HMService.
///
/// Service represents a HomeKit service and provides access to its characteristics.
/// This is the base class for autogenerated strongly-typed service wrappers.
///
/// Reference: https://developer.apple.com/documentation/homekit/hmservice
@Snapshotable
@MainActor
open class Service {
    internal let underlying: HMService
    private enum CharacteristicCacheEntry {
        case wrapper(AnyObject)
        case placeholder(HMCharacteristic)
    }

    private var characteristicCache: [UUID: CharacteristicCacheEntry] = [:]

    /// The unique identifier for this service type.
    public var serviceType: String {
        underlying.serviceType
    }

    /// A localized name for the service.
    public var name: String? {
        underlying.name
    }

    /// The accessory that provides this service.
    public var accessory: Accessory? {
        guard let hmAccessory = underlying.accessory else { return nil }
        return Accessory(underlying: hmAccessory)
    }

    /// Indicates whether this is the primary service for its accessory.
    public var isPrimaryService: Bool {
        underlying.isPrimaryService
    }

    /// Indicates whether this service is user-interactive.
    public var isUserInteractive: Bool {
        underlying.isUserInteractive
    }

    /// The unique instance identifier for this service.
    public var uniqueIdentifier: UUID {
        underlying.uniqueIdentifier
    }

    internal init(underlying: HMService) {
        self.underlying = underlying
    }

    /// Returns a typed characteristic for the specified type.
    ///
    /// - Parameter characteristicType: The characteristic type identifier.
    /// - Returns: A typed Characteristic wrapper, or nil if not found.
    public func characteristic<Value>(ofType characteristicType: String) -> Characteristic<Value>? {
        guard let hmCharacteristic = underlying.characteristics.first(where: { $0.characteristicType == characteristicType }) else {
            return nil
        }
        let key = hmCharacteristic.uniqueIdentifier

        if let entry = characteristicCache[key] {
            switch entry {
            case .wrapper(let anyWrapper):
                if let cached = anyWrapper as? Characteristic<Value> {
                    return cached
                }
                return nil
            case .placeholder(let placeholder):
                let wrapper = Characteristic<Value>(underlying: placeholder)
                characteristicCache[key] = .wrapper(wrapper)
                return wrapper
            }
        }

        let wrapper = Characteristic<Value>(underlying: hmCharacteristic)
        characteristicCache[key] = .wrapper(wrapper)
        return wrapper
    }

    /// Returns a generated characteristic wrapper for the specified type.
    ///
    /// - Parameter type: The generated characteristic class to cast into.
    /// - Returns: The generated characteristic wrapper or `nil` if the characteristic is missing.
    public func characteristic<C: GeneratedCharacteristic>(_ type: C.Type) -> C? {
        guard let hmCharacteristic = underlying.characteristics.first(where: { $0.characteristicType == C.characteristicType }) else {
            return nil
        }
        let key = hmCharacteristic.uniqueIdentifier

        if let entry = characteristicCache[key] {
            switch entry {
            case .wrapper(let anyWrapper):
                if let cached = anyWrapper as? C {
                    return cached
                }
                return nil
            case .placeholder(let placeholder):
                let wrapper = C(underlying: placeholder)
                characteristicCache[key] = .wrapper(wrapper)
                return wrapper
            }
        }

        let wrapper = C(underlying: hmCharacteristic)
        characteristicCache[key] = .wrapper(wrapper)
        return wrapper
    }

    /// Returns all characteristics of the service.
    ///
    /// - Returns: An array of untyped characteristic wrappers.
    public func allCharacteristics() -> [Characteristic<Any>] {
        return underlying.characteristics.map { characteristic in
            let key = characteristic.uniqueIdentifier

            if let entry = characteristicCache[key] {
                switch entry {
                case .wrapper(let anyWrapper):
                    if let cached = anyWrapper as? Characteristic<Any> {
                        return cached
                    }
                case .placeholder:
                    break
                }
            }

            let wrapper = Characteristic<Any>(underlying: characteristic)
            characteristicCache[key] = .wrapper(wrapper)
            return wrapper
        }
    }

    /// Returns a generated service wrapper when the underlying service type matches.
    ///
    /// - Parameter type: The generated service class to cast into.
    /// - Returns: The generated service wrapper or `nil` if the service types differ.
    public func typed<T: GeneratedService>(_ type: T.Type) -> T? {
        guard serviceType == T.serviceType else { return nil }
        return T(underlying: underlying)
    }
}

public extension Service {
    /// Warms the characteristic cache by preparing placeholder entries for every characteristic on this service.
    ///
    /// Reference: https://developer.apple.com/documentation/homekit/hmservice
    public func warmUpCharacteristicCache() {
        let clock = ContinuousClock()
        let start = clock.now

        for characteristic in underlying.characteristics {
            let key = characteristic.uniqueIdentifier
            if case .wrapper = characteristicCache[key] {
                continue
            }
            characteristicCache[key] = .placeholder(characteristic)
        }

        let duration = clock.now.duration(since: start).hkTimeInterval
        DiagnosticsLogger.shared.record(
            operation: .cacheWarmUp,
            context: DiagnosticsContext(
                accessoryName: underlying.accessory?.name,
                serviceType: serviceType,
                characteristicType: nil
            ),
            duration: duration,
            outcome: .success,
            metadata: [
                "scope": "service",
                "characteristics.count": String(underlying.characteristics.count)
            ]
        )
    }

    /// Clears cached characteristic wrappers and emits a diagnostics event describing the reset.
    public func resetCharacteristicCache() {
        let removedCount = characteristicCache.count
        characteristicCache.removeAll()

        DiagnosticsLogger.shared.record(
            operation: .cacheReset,
            context: DiagnosticsContext(
                accessoryName: underlying.accessory?.name,
                serviceType: serviceType,
                characteristicType: nil
            ),
            duration: 0,
            outcome: .success,
            metadata: [
                "scope": "service",
                "characteristics.removed": String(removedCount)
            ]
        )
    }
}

#else

/// A strongly-typed wrapper for HomeKit services (stub for non-HomeKit platforms).
@MainActor
open class Service {
    public var serviceType: String { "" }
    public var name: String? { nil }
    public var isPrimaryService: Bool { false }
    public var isUserInteractive: Bool { false }
    public var uniqueIdentifier: UUID { UUID() }

    public init() {}

    public func characteristic<Value>(ofType characteristicType: String) -> Characteristic<Value>? {
        nil
    }

    public func allCharacteristics() -> [Characteristic<Any>] {
        []
    }

    public func typed<T: GeneratedService>(_ type: T.Type) -> T? {
        nil
    }
}

/// Marker protocol for generated service wrappers in non-HomeKit builds.
@MainActor
public protocol GeneratedService {
    static var serviceType: String { get }
}

#endif
