import Foundation

#if canImport(HomeKit)
import HomeKit

/// Marker protocol that all generated characteristic wrappers conform to.
@MainActor
public protocol GeneratedCharacteristic {
    associatedtype WrappedValue

    /// The HomeKit characteristic type identifier represented by the wrapper.
    static var characteristicType: String { get }

    /// Initializes the wrapper from the underlying HomeKit characteristic.
    init(underlying: HMCharacteristic)
}

/// A strongly-typed wrapper for HMCharacteristic.
///
/// Characteristic provides type-safe read/write operations on HomeKit characteristics
/// with MainActor-bound async APIs. This is the base class for autogenerated
/// strongly-typed characteristic wrappers.
///
/// Reference: https://developer.apple.com/documentation/homekit/hmcharacteristic
@MainActor
open class Characteristic<Value> {
    internal let underlying: HMCharacteristic

    /// The unique identifier for this characteristic type.
    public var characteristicType: String {
        underlying.characteristicType
    }

    /// A localized description of the characteristic.
    public var localizedDescription: String {
        underlying.localizedDescription
    }

    /// The service that contains this characteristic.
    public var service: Service? {
        guard let hmService = underlying.service else { return nil }
        return Service(underlying: hmService)
    }

    /// Metadata describing the characteristic's properties.
    public var metadata: HMCharacteristicMetadata? {
        underlying.metadata
    }

    /// Indicates whether the characteristic supports reading.
    public var supportsRead: Bool {
        underlying.properties.contains(.readable)
    }

    /// Indicates whether the characteristic supports writing.
    public var supportsWrite: Bool {
        underlying.properties.contains(.writable)
    }

    /// Indicates whether the characteristic supports event notifications.
    public var supportsEventNotification: Bool {
        underlying.properties.contains(.supportsEventNotification)
    }

    public init(underlying: HMCharacteristic) {
        self.underlying = underlying
    }

    /// Reads the current value of the characteristic.
    ///
    /// - Returns: The characteristic's current value.
    /// - Throws: An error if the read operation fails or the value type is incompatible.
    public func read() async throws -> Value {
        let clock = ContinuousClock()
        let start = clock.now
        let context = CharacteristicContext(characteristic: underlying)

        do {
            let value: Value = try await withCheckedThrowingContinuation { continuation in
                underlying.readValue { error in
                    if let error {
                        let homeKitError = HomeKitError.characteristicTransport(
                            operation: .characteristicRead,
                            context: context,
                            underlying: error
                        )
                        continuation.resume(throwing: homeKitError)
                        return
                    }

                    guard let anyValue = self.underlying.value else {
                        continuation.resume(throwing: HomeKitError.characteristicValueUnavailable(context: context))
                        return
                    }

                    guard let typedValue = anyValue as? Value else {
                        continuation.resume(throwing: HomeKitError.characteristicTypeMismatch(
                            expected: String(describing: Value.self),
                            actual: String(describing: type(of: anyValue)),
                            context: context
                        ))
                        return
                    }

                    continuation.resume(returning: typedValue)
                }
            }

            recordDiagnostics(
                for: .characteristicRead,
                context: context,
                clock: clock,
                start: start,
                outcome: .success
            )

            return value
        } catch let homeKitError as HomeKitError {
            recordDiagnostics(
                for: .characteristicRead,
                context: context,
                clock: clock,
                start: start,
                outcome: .failure,
                error: homeKitError
            )
            throw homeKitError
        } catch {
            let wrapped = HomeKitError.characteristicTransport(
                operation: .characteristicRead,
                context: context,
                underlying: error
            )
            recordDiagnostics(
                for: .characteristicRead,
                context: context,
                clock: clock,
                start: start,
                outcome: .failure,
                error: wrapped
            )
            throw wrapped
        }
    }

    /// Writes a new value to the characteristic.
    ///
    /// - Parameter value: The value to write.
    /// - Throws: An error if the write operation fails.
    public func write(_ value: Value) async throws {
        let clock = ContinuousClock()
        let start = clock.now
        let context = CharacteristicContext(characteristic: underlying)

        do {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                underlying.writeValue(value) { error in
                    if let error {
                        let homeKitError = HomeKitError.characteristicTransport(
                            operation: .characteristicWrite,
                            context: context,
                            underlying: error
                        )
                        continuation.resume(throwing: homeKitError)
                    } else {
                        continuation.resume()
                    }
                }
            }

            recordDiagnostics(
                for: .characteristicWrite,
                context: context,
                clock: clock,
                start: start,
                outcome: .success
            )
        } catch let homeKitError as HomeKitError {
            recordDiagnostics(
                for: .characteristicWrite,
                context: context,
                clock: clock,
                start: start,
                outcome: .failure,
                error: homeKitError
            )
            throw homeKitError
        } catch {
            let wrapped = HomeKitError.characteristicTransport(
                operation: .characteristicWrite,
                context: context,
                underlying: error
            )
            recordDiagnostics(
                for: .characteristicWrite,
                context: context,
                clock: clock,
                start: start,
                outcome: .failure,
                error: wrapped
            )
            throw wrapped
        }
    }

    /// Enables or disables event notifications for this characteristic.
    ///
    /// - Parameter enabled: Whether to enable notifications.
    /// - Throws: An error if the operation fails.
    public func setNotifications(enabled: Bool) async throws {
        let clock = ContinuousClock()
        let start = clock.now
        let context = CharacteristicContext(characteristic: underlying)

        do {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                underlying.enableNotification(enabled) { error in
                    if let error {
                        let homeKitError = HomeKitError.characteristicTransport(
                            operation: .characteristicNotification,
                            context: context,
                            underlying: error
                        )
                        continuation.resume(throwing: homeKitError)
                    } else {
                        continuation.resume()
                    }
                }
            }

            recordDiagnostics(
                for: .characteristicNotification,
                context: context,
                clock: clock,
                start: start,
                outcome: .success
            )
        } catch let homeKitError as HomeKitError {
            recordDiagnostics(
                for: .characteristicNotification,
                context: context,
                clock: clock,
                start: start,
                outcome: .failure,
                error: homeKitError
            )
            throw homeKitError
        } catch {
            let wrapped = HomeKitError.characteristicTransport(
                operation: .characteristicNotification,
                context: context,
                underlying: error
            )
            recordDiagnostics(
                for: .characteristicNotification,
                context: context,
                clock: clock,
                start: start,
                outcome: .failure,
                error: wrapped
            )
            throw wrapped
        }
    }
}
private extension Characteristic {
    func recordDiagnostics(
        for operation: HomeKitOperation,
        context: CharacteristicContext,
        clock: ContinuousClock,
        start: ContinuousClock.Instant,
        outcome: DiagnosticsEvent.Outcome,
        error: HomeKitError? = nil
    ) {
        let duration = clock.now.duration(since: start)
        DiagnosticsLogger.shared.record(
            operation: operation,
            context: DiagnosticsContext(context),
            duration: duration.hkTimeInterval,
            outcome: outcome,
            metadata: error?.diagnosticsMetadata ?? [:]
        )
    }
}

extension Duration {
    var hkTimeInterval: TimeInterval {
        let components = self.components
        let seconds = Double(components.seconds)
        let attoseconds = Double(components.attoseconds) / 1_000_000_000_000_000_000
        return seconds + attoseconds
    }
}

#else

/// A strongly-typed wrapper for HomeKit characteristics (stub for non-HomeKit platforms).
@MainActor
open class Characteristic<Value> {
    public var characteristicType: String { "" }
    public var localizedDescription: String { "" }
    public var supportsRead: Bool { false }
    public var supportsWrite: Bool { false }
    public var supportsEventNotification: Bool { false }

    public init() {}

    public func read() async throws -> Value {
        throw HomeKitError.platformUnavailable(reason: "HomeKit characteristic reads are unavailable on this platform.")
    }

    public func write(_ value: Value) async throws {
        throw HomeKitError.platformUnavailable(reason: "HomeKit characteristic writes are unavailable on this platform.")
    }

    public func setNotifications(enabled: Bool) async throws {
        throw HomeKitError.platformUnavailable(reason: "HomeKit characteristic notifications are unavailable on this platform.")
    }
}

#endif
